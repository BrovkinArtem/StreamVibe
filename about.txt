JSX:
jsx - шаблонизатор разметки, изначально появился из мира react и редко используют без него
jsx - язык надстройка над js, в нём мы можем комбинировать js код и схожий с html синтаксис
    Содержание:
        - экспортируемая Функция в любом формате c большой буквы равная названию файла
        - возвращает такая функция разметку html

    Для основных страниц синтаксис:
        - функция - анонимная - export default function = () => { return ... }
        - return на несколько строк - return (...)
        - Одиночные теги всегда нужно закрывать
        - Чтобы рядом лежали элементы, например h1 и h2, нужно их предварительно вложить, например в div

jsx фрагмент - пустой парный тег - <> <> - который повзоляет избегать уровней вложенности и допустим разместить рядом h1 и h2

jsx компоненты можно вкладывать друг в друга

jsx компонент - Всё что пишется с большой буквы
jsx элемент - Всё что пишется с маленькой буквы (теги по сути)

т.к. jsx надстройка над js, то такие аттрибуты как class не будут доступны, ведь в js они зарезервированы
Для этого мы должны вместо class писать className

jsx функция всегда ожидает параметр - (props)
props содержит параметры указанные в компонентах в файлах к которым они подключаются
Если в параметрах передаём строку - ""
Если в параметрах передаём что-то другое - {}
С помощью props можно делать интересные вложенности, создавать внутри элементы, передавать их через props.children и другое
Также можно передавать булевые параметры для этого нужно только указать слово - isBig

Для каждого layouts, создаём папку и в ней 2 файла, jsx и index.js
    index.js - будет помогать нам убирать дубликат из пути и при подключении может теперь просто указывать название папки




База:
1. Название проекта (главную папку) называем в кебаб нотации
2. С этой вёрстки начинаем делать сайты в IDE WebStorm
3. Создаем проект через create minista@version
4. устанавливаем нужные DevDependencies
5. устанавливаем нужные Dependencies
6. Настраиваем алиасы - сокращения для путей (Улучшение передвижения по иерархии папок), Всё идёт от корня
7. Настраиваем конфиги (jsconfig.json, minista.config.js)
8. postcss плагины подключаем в отдельном файле, с доп проверкой
9. Если импортнули либу можем прямо к ней обращаться
10. Подготавливаем структуру проекта
    - public - Ресурсы которые не нужно обрабатывать сборщиков проектов
        В ней svg, mp4, постеры и тд
    - в src папки - assets, components, constants, layouts, modules, sections, styles, utils
    - в assets папки - fonts, icons, images
        assets - файлы, которые будут обрабатываться сборщиком проектов
        style - все различные стили
        utils - вспомогательные js функции
        constants - постоянные константные сущности (matchMedia с параметрами медиа запросов)
        modules - js модули (то же самое что раньше scripts)
        layouts - компоненты разметки, которые часто используются (header, footer ...)
        pages - файлы страниц (всего страниц 6 - 6 файлов)
        sections - разметки крупных секционных блоков
        components - БЭМ компоненты

11. Когда есть сборщик проектов, можно названия scss файлов начинать без _
12. Создаём базово папку helpers с constants, functions, mixins, media и настраиваем
13. в minista.config.js подрубаем путь scss helpers, найдёшь
14. Вспомогательные файлы в styles, подключаем в index.js (fonts, variables ...)
15. Создаём в папке src - global.jsx (Главный шаблон страницы который действует везде), все pages являются его children
16. Подрубаем favicon в global.jsx, title, и общую создаём общую структуру
17. После завершения проекта билдим его - npm run build
18. После билда, появляется папка dist - Всё то, что загружается на хостинг, чтобы сайт корректно отображался в сети
    Также сам проект сильно уменьшается при билде
19. Для просмотра билда - npm run preview

Sass:
(не уверен, что это так) 1. Благодаря pxtorem, можем писать 1200, вместо 1200px
2. Файлы scss тоже называем с большой (для layouts, components)
3. Кликабельные кнопки должны иметь область нажатия не менее 44px
4. scss переменные в качестве аргументов для fluid нельзя передать
5. Для задания плавности открытию dialog, помимо transition-duration,
    задаём transition-behavior: allow-descrete; - чтобы можно было включать анимацию для того же open,
    а также прописываем саму анимацию в @starting-style {}
6. column-count: 2; - хитрое свойство применяется без грид, делит на равное кол-во строчки (в данном случае 2)
7. break-inside - avoid-column - убираем перенос если слишком много текста в одной из строк (чтобы этот текст глупо не переносился на другую колонку)
8. clamp для полупиксилей использовать нерационально
9. inset-inline - если нужно задать одинаковые left и right
10. display: var(--tabsNavigationDisplay, flex); - если браузер обнаружит переменную, поставит её значение для display, если нет то flex
11. Для смешивания цветов в css есть свойство - background-color: color-mix(
                                                      in srgb,          здесь указывается в каком формате цветов работаем
                                                      var(--color-black) 60%, первый цвет
                                                      transparent             второй цвет
                                                    );
12. для инпут - appearance: none; для кастомной настройки
13. Неочевидная функциональность content: ' *' / ''; где / '' - указывается чтобы скринридеры не озвучивали звездочку
14. overscroll-behavior: none; - чтобы после окончания скролла в селекте, не скролилась дальше вся страница

Скрипты:
1. В scripts в package.json приведены возможные способы запуска проекта
2. Если внутри парных тегов script ничего не указать, можно обойтись одним
3. Путь до main.js строго абсолютный - "/src/main.js"

html:
1. loading="eager" - стандартная не ленивая загрузка

jsx:
1. Мы подключали библиотеку classNames, в рамках которой теперь можем указывать удобно комбинированные классы, передавая туда только аргументы что написать в className
2. jsx (и возможно реакт) крут для написания разметки тем, что нам не нужно копирать куча раз одинаковые конструкции кода,
    мы можем использовать например функцию map с аргументами для заполнения меню и точно также прорабатывать карточки и прочее
3. Значение булевому пропу можно не указывать   -   isLabelHidden (это уже будет true)
4. && - это по сути одиночный if, если есть то делаем && ..., если нет, то ничего
5. В props при деструтуризации полезно помечать некоторые методы так:
                /**
                 * '' (default) | 'transparent'
                 */
6. Оператор опциональной последовательности + пример его использования - links?.length > 0, ссылок больше чем 0
7. Внутри какого-нибудь компонента, можно также разместить новую папку components, где уже будут компоненты компонента)
8. Создали абстрактный класс BaseComponent
9. в label, в jsx зарезервирован for, поэтому там используется htmlFor

Интересные моменты:
1. В терминале могут быть желтые сообщения, допустим о пропущенном файле который мы уже успели удалить, это сообщение показывается по причине кэша
2. В Settings => Editor => File and Code Templates. Можно настраивать свои шаблоны для быстрого создания повторяющихся компонентов
    Мы в рамках курса сделали 2 таких компонента, jsx, jsx + стили (у обоих есть index.js для красивого импорта и предзаполненность)
3. В WebStorm hotkey на сплит экрана - cntrl + \
4. cntrl + shift + f - поиск файлов по проекту
5. При разработке, лучше смотреть сайт в режиме инкогнито, чтобы всегда отображалась новая версия сайта, бывает так что кэширование плохо работает и не всё сразу может отобразиться
6. Для реализации слайдера используется библиотека swiper
7. cntrl + . - добавление импорта, если не было
8. cntrl + enter - начать текст с новой строки
9. Если что-то не работает, то хорошим решением будет зайти с режима инкогнито, так как из-за кэша, что-то может не обновиться